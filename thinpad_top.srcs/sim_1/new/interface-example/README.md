# 数据包收发后端示例程序

## 用法

在linux环境（或者Windows下，用实验一的Msys环境）进行make，就可以产生`baseram.mem`文件与可执行文件的反汇编结果。

## 接口规定

### 数据包传输

内存中以`0x80600000`地址开始的`2048*128`长度内存区域被用来作为数据包的缓冲区。每个包被分配给一个固定长度`2048`（大于以太网帧长度的最小2次幂）的内存块，一共有128个，按照0~127编号。
路由器控制器按照循环的方式依次向各个块写入收到的数据包，并通过串口给CPU提供一个只读的寄存器，用于指示当前正在写入的内存块编号。
为了方便，记这个编号为`router_buf_index`，这个寄存器被映射到内存中的地址`0xBFD00400`处。

硬件上没有实现完全的循环队列，`router_buf_index`仅仅相当于队列的队尾，队首指针由CPU进行维护。
如果收包过快而CPU处理跟不上速度，可能会出现队尾“套圈”追上队首的现象，此时会发生丢包。

发包是以写串口的方式进行的。地址`0xBFD00404`映射到路由器模块的发包状态`router_send_state`，如果是`1`表明正在进行发包操作，此时通过写串口进行的发包尝试无效。
CPU可以对以上串口进行轮询，当读到`0`时，可以将待发送包的首地址写入`0xBFD00408`，此后`router_send_state`拉高为`1`，路由器进行发包。

### 硬件转发表项修改

路由器表开放了四个接口，程序可以写入如下寄存器，作为待插入表项的信息：

- `0xBFD00410`：子网地址
- `0xBFD00414`：下一跳IP地址
- `0xBFD00418`：子网网段长度（0~32,32表示单独的一个IP地址）
- `0xBFD0041C`：下一跳的网络接口（编号0~3）

以上的IP地址都需要是小端序。

此外，控制寄存器`0xBFD00420`支持表项插入状态的询问，以及发送表项的确认。此寄存器是读写的，读入`0`表示路由表空闲，读入`1`表示路由表正在插入表项。
（注：由于路由器时钟域频率较高，swh猜测大概只需要2~3个CPU时钟周期就可以完成表项的一次插入。）

## 数据包内存布局

长度和数据确定一个包的边界与内容。无论是收包还是发包，我们都以如下的内存布局来存储：

- 前 4 bytes：数据包长度`L`。
- 后`L`bytes：数据包内容。

也就是说，接收缓冲区中每个块的首4字节都是长度，收到包的真正数据从偏移为4的位置开始；发送包时传递的地址处开始的4个字节是包长度，包的数据在这4个字节之后。

## 示例文件

- `loopback.c`: C语言实现了包的收发，将收到的包全部原样转发出去，实现软件层面的Loopback。**需要支持指令slti。**
- `loopback.s`: 汇编实现了软件Loopback程。执行命令`make loopback.o`可以从汇编代码生成可执行文件，`make`可以生成纯指令机器码的二进制文件。**需要支持指令slti。**
- `routerio.s`: 汇编单独实现了包的收发，可以单独编译后与其他C程序共同链接。
- `header_gen.py`: 从C语言编译链接成的可执行文件机器码不能直接用在板子上，原因有二：
  - 没有OS，但是又需要对栈顶指针`sp`、`fp`甚至`ra`的访问。
  - 程序指令不是从地址`0x0`开始，而`jal`指令又会带来绝对地址的跳转，内存管理出现混乱。
  解决第一个问题的方法就是在生成的可执行文件前加`sp`、`fp`、`ra`的初始化指令；
  解决第二个问题swh仍然没有比较简便的方案，目前的权宜之计只有：编译->反编译->手动改分支跳转标签->编译……
